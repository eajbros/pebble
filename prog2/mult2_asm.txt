# multiply two 8-bit unsigned numbers
# inputs:  mem[0] = A, mem[1] = B
# outputs: mem[2] = high byte, mem[3] = low byte

# init result_high = 0, result_low = 0
0:  LI R0, 0
1:  LI R2, 2
2:  SW R0, R2          # mem[2] = 0 (high byte)

3:  LI R2, 3
4:  SW R0, R2          # mem[3] = 0 (low byte)

# counter = B
5:  LI R2, 1
6:  LW R1, R2          # R1 = mem[1] = B
7:  LI R3, 4
8:  SW R1, R3          # mem[4] = B

# loop start: if counter == 0, jump to halt
9:  LI R3, 4
10: LW R1, R3          # R1 = counter

11: LI R0, 19
12: ADD R2, R0, R0     # R2 = address of HALT
13: LI R0, 0
14: BEQ R1, R0, R2     # if counter == 0, end program

# new_low = old_low + A
15: LI R2, 0
16: LW R0, R2          # R0 = A
17: LI R2, 3
18: LW R1, R2          # R1 = old low byte
19: ADD R0, R0, R1     # R0 = new low byte
20: SW R0, R2          # mem[3] = new low byte

# check for carry
21: SLT R2, R0, R1     # R2 = 1 if overflow occurred
22: LI R0, 0
23: LI R1, 30
24: BEQ R2, R0, R1     # if no carry, skip increment

# carry happened: high++
25: LI R2, 2
26: LW R1, R2          # R1 = high byte
27: LI R0, 1
28: ADD R0, R0, R1
29: SW R0, R2          # mem[2] = updated high byte

# counter--
30: LI R3, 4
31: LW R1, R3          # R1 = counter
32: LI R0, 1
33: SUB R1, R1, R0     # counter = counter - 1
34: SW R1, R3          # mem[4] = updated counter

# jump back to loop start
35: LI R0, 0
36: LI R2, 9
37: BEQ R0, R0, R2     # unconditional jump

# done
38: END