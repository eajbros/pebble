# 8-bit Unsigned Multiplication with Carry Propagation
# A * B using repeated addition with 16-bit result
# Input: mem[0]=A (multiplicand), mem[1]=B (multiplier)
# Output: mem[2]=high byte, mem[3]=low byte
#
# Algorithm:
#   result_high = 0
#   result_low = 0
#   for (counter = B; counter > 0; counter--)
#       old_low = result_low
#       result_low += A
#       if (result_low < old_low)  // carry occurred
#           result_high += 1
#
# Memory usage:
#   mem[0] = A (input)
#   mem[1] = B (input)
#   mem[2] = result high byte (output)
#   mem[3] = result low byte (output)
#   mem[4] = loop counter (decrements from B to 0)



# Annotated assembly for 8-bit unsigned multiply with carry propagation
LI R0, 0        # R0 = 0 (for initialization)
LI R2, 2        # R2 = 2 (address)
SW R0, R2       # mem[2] = 0 (high byte)
LI R2, 3        # R2 = 3 (address)
SW R0, R2       # mem[3] = 0 (low byte)
LI R2, 1        # R2 = 1 (address of B)
LW R1, R2       # R1 = mem[1] = B
LI R3, 4        # R3 = 4 (counter address)
SW R1, R3       # mem[4] = B (initialize counter)
LI R3, 4        # R3 = 4 (counter address, reload before use)
LW R1, R3       # R1 = mem[4] = counter
LI R0, 19       # R0 = 19 (address of HALT)
ADD R0, R0, R2  # R0 = R0 + R2 (compute jump address)
LI R0, 0        # R0 = 0 (for comparison)
BEQ R1, R0, R2  # if counter == 0, goto HALT
LI R2, 0        # R2 = 0 (address of A)
LW R0, R2       # R0 = mem[0] = A
LI R2, 3        # R2 = 3 (result_low address)
LW R1, R2       # R1 = mem[3] = old_low
ADD R0, R0, R1  # R0 = A + old_low = new_low
SW R0, R2       # mem[3] = new_low
SLT R2, R0, R1  # R2 = 1 if new_low < old_low (carry)
LI R0, 0        # R0 = 0
LI R1, 30       # R1 = 30 (skip carry address)
BEQ R2, R0, R1  # if no carry, skip increment
LI R2, 2        # R2 = 2 (high byte address)
LW R1, R2       # R1 = mem[2] = high byte
LI R0, 1        # R0 = 1
ADD R0, R1, R0  # R0 = high byte + 1
SW R0, R2       # mem[2] = new high byte
LI R3, 4        # R3 = 4 (counter address)
LW R1, R3       # R1 = mem[4] = counter
LI R0, 1        # R0 = 1
SUB R1, R0, R1  # R1 = counter - 1
SW R1, R3       # mem[4] = counter
LI R0, 0        # R0 = 0
LI R2, 9        # R2 = 9 (loop start address)
BEQ R0, R0, R2  # unconditional jump to loop start
HALT            # end of program
