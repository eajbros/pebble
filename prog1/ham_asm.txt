# Closest pair with Hamming Distance

# initialize constants and scratch memory
000: LI R0, 8
001: LI R2, 16
002: LI R2, 8
003: SW R0, R2          # mem[8] = 8 (number of bits per value)

004: LI R0, 0
005: LI R2, 9
006: SW R0, R2          # mem[9] = 0 (constant zero)

007: LI R0, 0
008: LI R2, 19
009: LI R2, 12
010: SW R0, R2          # mem[12] = 0 (current distance accumulator)

011: LI R0, 15
012: LI R2, 20
013: LI R2, 13
014: SW R0, R2          # mem[13] = 15 (last index in array)

015: LI R0, 1
016: LI R2, 18
017: LI R2, 10
018: SW R0, R2          # mem[10] = 1 (increment / mask constant)


# load current distance and do setup before main loop
019: LI R3, 19
020: LI R2, 12
021: LW R0, R2          # R0 = current distance
022: ADD R2, R0, R0     # filler ALU op
023: LI R2, 12
024: SW R0, R2          # store distance back


# check whether to enter main pair-processing loop
025: LI R0, 15
026: LI R3, 28          # jump target for main computation
027: LI R2, 12
028: LW R1, R2          # R1 = current distance
029: OR R2, R0, R1
030: BEQ R0, R2, R3     # if distance == 0, jump into loop body


# reset distance accumulator for a new pair
031: LI R0, 1
032: LI R2, 18
033: ADD R2, R0, R0
034: LI R2, 12
035: SW R0, R2          # mem[12] = 1


# prepare scratch registers for bit-level hamming computation
036: LI R2, 12
037: LW R1, R2          # load current distance
038: LI R0, 18
039: LI R3, 16
040: LI R2, 26
041: LW R1, R2          # load loop-related value
042: AND R0, R0, R0     # no-op / timing filler

043: LI R2, 11
044: SW R0, R2          # mem[11] = working value

045: LI R0, 0
046: LI R2, 14
047: SW R0, R2          # mem[14] = 0 (bit counter / temp accumulator)


# inner loop: process one bit of the pair
048: LI R1, 1
049: LI R3, 18
050: LI R2, 11
051: LW R1, R2          # load working value
052: LI R3, 26
053: SUB R2, R0, R1     # compare bit / check condition
054: LW R0, R3          # load loop control value
055: ADD R1, R1, R1     # shift working value left

056: LI R2, 14
057: LW R0, R2          # load current bit count
058: OR R1, R0, R1      # accumulate hamming difference
059: LI R2, 14
060: SW R1, R2          # store updated distance


# unconditional jump to continue bit loop
061: LI R3, 26
062: BEQ R3, R3, R3     # always true, jump back to bit loop


# shift scratch registers for next bit
063: LI R0, 18
064: LI R3, 18
065: LI R2, 11
066: LW R0, R2          # load working value
067: SHL R0, R0, R0     # shift left
068: LI R2, 11
069: SW R0, R2          # store shifted value

070: LI R0, 18
071: LI R3, 18
072: LI R2, 14
073: LW R0, R2          # load distance accumulator
074: SHL R0, R0, R0     # shift accumulator
075: LI R2, 11
076: SW R0, R2          # store back to working register


# check if bit loop should exit
077: LI R3, 26
078: BEQ R3, R0, R1     # branch when bit-processing is complete


# load current distance and compare against min/max
079: LI R0, 18
080: LI R3, 18
081: LI R2, 14
082: LW R0, R2          # R0 = computed distance
083: LI R1, 31
084: LI R2, 16
085: BEQ R3, R3, R3     # unconditional jump to update logic


# update min/max candidate paths
086: LI R0, 19
087: LI R3, 19
088: LI R2, 13
089: LW R0, R2          # load comparison value
090: OR R2, R0, R1

091: LI R3, 17
092: LI R2, 14
093: LW R0, R2          # load distance
094: BEQ R3, R0, R1     # branch based on comparison result


# alternate update path
095: LI R0, 18
096: LI R3, 18
097: LI R2, 13
098: LW R0, R2
099: OR R2, R0, R1

100: LI R3, 17
101: LI R2, 14
102: LW R0, R2
103: BEQ R3, R2, R3     # branch to next control state


# store updated min distance
104: LI R0, 18
105: LI R3, 18
106: ADD R2, R0, R0
107: LI R2, 12
108: SW R0, R2          # mem[12] = updated min distance


# store updated max distance
109: LI R0, 17
110: LI R3, 17
111: ADD R2, R0, R0
112: LI R2, 10
113: SW R0, R2          # mem[10] = updated max distance


# advance to next pair or loop back
114: LI R3, 25
115: BEQ R3, R0, R1     # branch to next pair


# check outer loop termination
116: LI R0, 15
117: LI R3, 28
118: LI R2, 12
119: LW R1, R2
120: LI R1, 31
121: LI R3, 21
122: BEQ R0, R3, R3     # jump when all pairs processed


# final writeback of results
123: LI R0, 19
124: LI R3, 19
125: ADD R2, R0, R0
126: LI R2, 12
127: SW R0, R2          # write final min distance

128: LI R3, 27
129: BEQ R3, R2, R3     # jump to final store


# store results to output locations
130: LI R0, 16
131: LI R2, 17
132: LI R2, 8
133: SW R0, R2          # write min distance to memory

134: LI R2, 8
135: SW R1, R2          # write max distance to memory

136: END                # program finished